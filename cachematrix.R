## Matrix inversion is usually a costly computation and there may be some benefit to caching 
## the inverse of a matrix rather than compute it repeatedly (there are also alternatives to 
## matrix inversion that we will not discuss here). Your assignment is to write a pair of 
## functions that cache the inverse of a matrix.

## The following function is designed to create a matrix object to cache its inverse

makeCacheMatrix <- function(x = matrix()) {
  ## creation of a square invertible matrix
  ## returning a list containing a function to
  ## 1. Set the value of the matrix
  ## 2. get the value of the matrix
  ## 3. set the value of the inverse
  ## 4. get the value of the inverse
  
  invrs = NULL
  set = function(y) {
    x <<- y
    invrs <<- NULL
  }
  get = function() x
  setinvrs = function(solve) invrs <<- solve
  getinvrs = function() invrs
  list(set=set, get=get, setinvrs=setinvrs, getinvrs=getinvrs)
}

## The following function calcuates the inverse of the matrix generated by makeCacheatrix.
## Cavet: if the inverse is already calculated and there is no change to the matrix
## cacheSolve wil just retrieve the inverse directly from the cache

cacheSolve <- function(x, ...) {
  ## Return a matrix that is the inverse of 'x'
  
  invrs = x$getinvrs()
  
  ## the following is if the inverse has already been calculated
  if (!is.null(invrs)){
    ## gets the data from the cache
    message("getting cached data")
    return(invrs)
  }
  
  ## else, we need to calculate the inverse
  matrixData = x$get()
  invrs = solve(matrixData, ...)
  x$setinvrs(inv)
  
  invrs
}
